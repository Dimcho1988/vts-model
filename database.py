from __future__ import annotations
import os
from typing import Optional
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

def get_engine():
    db_url = os.environ.get("DATABASE_URL")
    if not db_url:
        raise RuntimeError("DATABASE_URL not set. Put it in Streamlit secrets or environment.")
    return create_engine(db_url, pool_pre_ping=True)

def get_session():
    return sessionmaker(bind=get_engine(), autoflush=False, autocommit=False)()

_SCHEMA_SQL = """
set search_path to public;

create table if not exists profiles (
  athlete_key text primary key,
  hr_max integer
);

create table if not exists workouts (
  id bigint generated by default as identity primary key,
  athlete_key text,
  start_time text,
  duration_s double precision,
  distance_m double precision,
  avg_hr double precision,
  avg_speed_mps double precision,
  notes text,
  strava_id bigint,
  has_streams boolean default false
);
create index if not exists idx_workouts_ath_time on workouts(athlete_key, start_time);
create unique index if not exists uq_workouts_strava_id on workouts(strava_id);

create table if not exists hr_speed_points (
  id bigint generated by default as identity primary key,
  workout_id bigint,
  t_bin_start text,
  mean_hr double precision,
  mean_vflat double precision
);
create index if not exists idx_hrv_workout on hr_speed_points(workout_id);

create table if not exists tokens (
  athlete_key text primary key,
  strava_athlete_id text,
  access_token text,
  refresh_token text,
  expires_at bigint
);
"""

def init_db():
    with get_engine().begin() as conn:
        conn.exec_driver_sql(_SCHEMA_SQL)

def upsert_profile(athlete_key: str, hr_max: Optional[int]) -> None:
    sql = """
    insert into profiles(athlete_key, hr_max)
    values (:athlete_key, :hr_max)
    on conflict (athlete_key) do update set hr_max=excluded.hr_max;
    """
    with get_engine().begin() as conn:
        conn.execute(text(sql), {"athlete_key": athlete_key, "hr_max": hr_max})

def get_profile(athlete_key: str):
    sql = "select athlete_key, hr_max from profiles where athlete_key=:athlete_key limit 1"
    with get_engine().begin() as conn:
        row = conn.execute(text(sql), {"athlete_key": athlete_key}).mappings().first()
        return dict(row) if row else None

def insert_workout(athlete_key: str, start_time_iso: str, duration_s: float,
                   distance_m: float, avg_hr: float=None,
                   avg_speed_mps: float=None, notes: str=None,
                   strava_id: int=None) -> int:
    sql = """
    insert into workouts(athlete_key, start_time, duration_s, distance_m, avg_hr, avg_speed_mps, notes, strava_id)
    values (:athlete_key, :start_time, :duration_s, :distance_m, :avg_hr, :avg_speed_mps, :notes, :strava_id)
    returning id;
    """
    with get_engine().begin() as conn:
        new_id = conn.execute(text(sql), {
            "athlete_key": athlete_key,
            "start_time": start_time_iso,
            "duration_s": duration_s,
            "distance_m": distance_m,
            "avg_hr": avg_hr,
            "avg_speed_mps": avg_speed_mps,
            "notes": notes,
            "strava_id": strava_id
        }).scalar_one()
        return int(new_id)

def list_workouts(athlete_key: str, limit: int=100):
    sql = """
    select id, athlete_key, start_time, duration_s, distance_m, avg_hr, avg_speed_mps, notes, strava_id, has_streams
    from workouts
    where athlete_key=:athlete_key
    order by start_time desc
    limit :limit
    """
    with get_engine().begin() as conn:
        rows = conn.execute(text(sql), {"athlete_key": athlete_key, "limit": limit}).mappings().all()
        return [dict(r) for r in rows]

def mark_workout_has_streams(workout_id: int, has_streams: bool=True) -> None:
    sql = "update workouts set has_streams=:hs where id=:id"
    with get_engine().begin() as conn:
        conn.execute(text(sql), {"hs": has_streams, "id": workout_id})

def insert_hr_speed_points(workout_id: int, points):
    sql = """
    insert into hr_speed_points(workout_id, t_bin_start, mean_hr, mean_vflat)
    values (:workout_id, :t_bin_start, :mean_hr, :mean_vflat)
    """
    with get_engine().begin() as conn:
        cnt = 0
        for p in points:
            conn.execute(text(sql), {
                "workout_id": workout_id,
                "t_bin_start": p["t_bin_start"],
                "mean_hr": p["mean_hr"],
                "mean_vflat": p["mean_vflat"],
            })
            cnt += 1
        return cnt

def get_hr_speed_points(workout_id: int, limit: int=10000):
    sql = """
    select id, workout_id, t_bin_start, mean_hr, mean_vflat
    from hr_speed_points
    where workout_id=:workout_id
    order by t_bin_start asc
    limit :limit
    """
    with get_engine().begin() as conn:
        rows = conn.execute(text(sql), {"workout_id": workout_id, "limit": limit}).mappings().all()
        return [dict(r) for r in rows]